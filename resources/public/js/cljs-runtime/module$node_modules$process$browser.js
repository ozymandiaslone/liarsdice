shadow$provide.module$node_modules$process$browser = function(require, module, exports) {
  function defaultSetTimout() {
    throw Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw Error("clearTimeout has not been defined");
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      return cachedSetTimeout = setTimeout, setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      return cachedClearTimeout = clearTimeout, clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  function cleanUpNextTick() {
    draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
  }
  function drainQueue() {
    if (!draining) {
      var timeout = runTimeout(cleanUpNextTick);
      draining = !0;
      for (var len = queue.length; len;) {
        currentQueue = queue;
        for (queue = []; ++queueIndex < len;) {
          currentQueue && currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = !1;
      runClearTimeout(timeout);
    }
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  require = module.exports = {};
  try {
    var cachedSetTimeout = typeof setTimeout === "function" ? setTimeout : defaultSetTimout;
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    var cachedClearTimeout = typeof clearTimeout === "function" ? clearTimeout : defaultClearTimeout;
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
  var queue = [], draining = !1, currentQueue, queueIndex = -1;
  require.nextTick = function(fun) {
    var args = Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    queue.length !== 1 || draining || runTimeout(drainQueue);
  };
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  require.title = "browser";
  require.browser = !0;
  require.env = {};
  require.argv = [];
  require.version = "";
  require.versions = {};
  require.on = noop;
  require.addListener = noop;
  require.once = noop;
  require.off = noop;
  require.removeListener = noop;
  require.removeAllListeners = noop;
  require.emit = noop;
  require.prependListener = noop;
  require.prependOnceListener = noop;
  require.listeners = function(name) {
    return [];
  };
  require.binding = function(name) {
    throw Error("process.binding is not supported");
  };
  require.cwd = function() {
    return "/";
  };
  require.chdir = function(dir) {
    throw Error("process.chdir is not supported");
  };
  require.umask = function() {
    return 0;
  };
};

//# sourceMappingURL=module$node_modules$process$browser.js.map
