shadow$provide.module$node_modules$scheduler$cjs$scheduler_development = function(require, module, exports) {
  (function() {
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a: {
        for (;;) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (parent !== void 0 && compare(parent, node) > 0) {
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          } else {
            break a;
          }
        }
      }
    }
    function peek(heap) {
      heap = heap[0];
      return heap === void 0 ? null : heap;
    }
    function pop(heap) {
      var first = heap[0];
      if (first !== void 0) {
        var last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: {
            for (var index = 0, length = heap.length; index < length;) {
              var leftIndex = (index + 1) * 2 - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (left !== void 0 && compare(left, last) < 0) {
                right !== void 0 && compare(right, left) < 0 ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              } else if (right !== void 0 && compare(right, last) < 0) {
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              } else {
                break a;
              }
            }
          }
        }
        return first;
      }
      return null;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return diff !== 0 ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); timer !== null;) {
        if (timer.callback === null) {
          pop(timerQueue);
        } else if (timer.startTime <= currentTime) {
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        } else {
          break;
        }
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = !1;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled) {
        if (peek(taskQueue) !== null) {
          isHostCallbackScheduled = !0, requestHostCallback(flushWork);
        } else {
          var firstTimer = peek(timerQueue);
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
      }
    }
    function flushWork(hasTimeRemaining, initialTime) {
      isHostCallbackScheduled = !1;
      isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, cancelHostTimeout());
      isPerformingWork = !0;
      var previousPriorityLevel = currentPriorityLevel;
      try {
        advanceTimers(initialTime);
        for (currentTask = peek(taskQueue); currentTask !== null && (!(currentTask.expirationTime > initialTime) || hasTimeRemaining && !exports.unstable_shouldYield());) {
          var callback = currentTask.callback;
          if (typeof callback === "function") {
            currentTask.callback = null;
            currentPriorityLevel = currentTask.priorityLevel;
            var continuationCallback = callback(currentTask.expirationTime <= initialTime);
            initialTime = exports.unstable_now();
            typeof continuationCallback === "function" ? currentTask.callback = continuationCallback : currentTask === peek(taskQueue) && pop(taskQueue);
            advanceTimers(initialTime);
          } else {
            pop(taskQueue);
          }
          currentTask = peek(taskQueue);
        }
        if (currentTask !== null) {
          var JSCompiler_inline_result = !0;
        } else {
          var firstTimer = peek(timerQueue);
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - initialTime);
          JSCompiler_inline_result = !1;
        }
        return JSCompiler_inline_result;
      } finally {
        currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
      }
    }
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    if (typeof window === "undefined" || typeof MessageChannel !== "function") {
      var _callback = null, _timeoutID = null, _flushCallback = function() {
        if (_callback !== null) {
          try {
            var currentTime = exports.unstable_now();
            _callback(!0, currentTime);
            _callback = null;
          } catch (e) {
            throw setTimeout(_flushCallback, 0), e;
          }
        }
      };
      var requestHostCallback = function(cb) {
        _callback !== null ? setTimeout(requestHostCallback, 0, cb) : (_callback = cb, setTimeout(_flushCallback, 0));
      };
      var requestHostTimeout = function(cb, ms) {
        _timeoutID = setTimeout(cb, ms);
      };
      var cancelHostTimeout = function() {
        clearTimeout(_timeoutID);
      };
      exports.unstable_shouldYield = function() {
        return !1;
      };
      var requestPaint = exports.unstable_forceFrameRate = function() {
      };
    } else {
      var _setTimeout = window.setTimeout, _clearTimeout = window.clearTimeout;
      typeof console !== "undefined" && (requestPaint = window.cancelAnimationFrame, typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), typeof requestPaint !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"));
      var isMessageLoopRunning = !1, scheduledHostCallback = null, taskTimeoutID = -1, yieldInterval = 5, deadline = 0;
      exports.unstable_shouldYield = function() {
        return exports.unstable_now() >= deadline;
      };
      requestPaint = function() {
      };
      exports.unstable_forceFrameRate = function(fps) {
        fps < 0 || fps > 125 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : yieldInterval = fps > 0 ? Math.floor(1000 / fps) : 5;
      };
      var channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = function() {
        if (scheduledHostCallback !== null) {
          var currentTime = exports.unstable_now();
          deadline = currentTime + yieldInterval;
          try {
            scheduledHostCallback(!0, currentTime) ? port.postMessage(null) : (isMessageLoopRunning = !1, scheduledHostCallback = null);
          } catch (error) {
            throw port.postMessage(null), error;
          }
        } else {
          isMessageLoopRunning = !1;
        }
      };
      requestHostCallback = function(callback) {
        scheduledHostCallback = callback;
        isMessageLoopRunning || (isMessageLoopRunning = !0, port.postMessage(null));
      };
      requestHostTimeout = function(callback, ms) {
        taskTimeoutID = _setTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      };
      cancelHostTimeout = function() {
        _clearTimeout(taskTimeoutID);
        taskTimeoutID = -1;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1;
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_continueExecution = function() {
      isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback(flushWork));
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return peek(taskQueue);
    };
    exports.unstable_next = function(eventHandler) {
      switch(currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = requestPaint;
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch(priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      typeof options === "object" && options !== null ? (options = options.delay, options = typeof options === "number" && options > 0 ? currentTime + options : currentTime) : options = currentTime;
      switch(priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 10000;
          break;
        default:
          timeout = 5000;
      }
      timeout = options + timeout;
      priorityLevel = {id:taskIdCounter++, callback, priorityLevel, startTime:options, expirationTime:timeout, sortIndex:-1};
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), peek(taskQueue) === null && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? cancelHostTimeout() : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback(flushWork)));
      return priorityLevel;
    };
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  })();
};

//# sourceMappingURL=module$node_modules$scheduler$cjs$scheduler_development.js.map
