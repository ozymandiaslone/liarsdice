shadow$provide.module$node_modules$scheduler$cjs$scheduler_tracing_development = function(require, module, exports) {
  (function() {
    function onInteractionTraced(interaction) {
      var didCatchError = !1, caughtError = null;
      subscribers.forEach(function(subscriber) {
        try {
          subscriber.onInteractionTraced(interaction);
        } catch (error) {
          didCatchError || (didCatchError = !0, caughtError = error);
        }
      });
      if (didCatchError) {
        throw caughtError;
      }
    }
    function onInteractionScheduledWorkCompleted(interaction) {
      var didCatchError = !1, caughtError = null;
      subscribers.forEach(function(subscriber) {
        try {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        } catch (error) {
          didCatchError || (didCatchError = !0, caughtError = error);
        }
      });
      if (didCatchError) {
        throw caughtError;
      }
    }
    function onWorkScheduled(interactions, threadID) {
      var didCatchError = !1, caughtError = null;
      subscribers.forEach(function(subscriber) {
        try {
          subscriber.onWorkScheduled(interactions, threadID);
        } catch (error) {
          didCatchError || (didCatchError = !0, caughtError = error);
        }
      });
      if (didCatchError) {
        throw caughtError;
      }
    }
    function onWorkStarted(interactions, threadID) {
      var didCatchError = !1, caughtError = null;
      subscribers.forEach(function(subscriber) {
        try {
          subscriber.onWorkStarted(interactions, threadID);
        } catch (error) {
          didCatchError || (didCatchError = !0, caughtError = error);
        }
      });
      if (didCatchError) {
        throw caughtError;
      }
    }
    function onWorkStopped(interactions, threadID) {
      var didCatchError = !1, caughtError = null;
      subscribers.forEach(function(subscriber) {
        try {
          subscriber.onWorkStopped(interactions, threadID);
        } catch (error) {
          didCatchError || (didCatchError = !0, caughtError = error);
        }
      });
      if (didCatchError) {
        throw caughtError;
      }
    }
    function onWorkCanceled(interactions, threadID) {
      var didCatchError = !1, caughtError = null;
      subscribers.forEach(function(subscriber) {
        try {
          subscriber.onWorkCanceled(interactions, threadID);
        } catch (error) {
          didCatchError || (didCatchError = !0, caughtError = error);
        }
      });
      if (didCatchError) {
        throw caughtError;
      }
    }
    var interactionIDCounter = 0, threadIDCounter = 0;
    exports.__interactionsRef = null;
    exports.__subscriberRef = null;
    exports.__interactionsRef = {current:new Set()};
    exports.__subscriberRef = {current:null};
    var subscribers = null;
    subscribers = new Set();
    exports.unstable_clear = function(callback) {
      var prevInteractions = exports.__interactionsRef.current;
      exports.__interactionsRef.current = new Set();
      try {
        return callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;
      }
    };
    exports.unstable_getCurrent = function() {
      return exports.__interactionsRef.current;
    };
    exports.unstable_getThreadID = function() {
      return ++threadIDCounter;
    };
    exports.unstable_subscribe = function(subscriber) {
      subscribers.add(subscriber);
      subscribers.size === 1 && (exports.__subscriberRef.current = {onInteractionScheduledWorkCompleted, onInteractionTraced, onWorkCanceled, onWorkScheduled, onWorkStarted, onWorkStopped});
    };
    exports.unstable_trace = function(name, timestamp, callback) {
      var threadID = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, interaction = {__count:1, id:interactionIDCounter++, name, timestamp}, prevInteractions = exports.__interactionsRef.current, interactions = new Set(prevInteractions);
      interactions.add(interaction);
      exports.__interactionsRef.current = interactions;
      var subscriber = exports.__subscriberRef.current;
      try {
        if (subscriber !== null) {
          subscriber.onInteractionTraced(interaction);
        }
      } finally {
        try {
          if (subscriber !== null) {
            subscriber.onWorkStarted(interactions, threadID);
          }
        } finally {
          try {
            var returnValue = callback();
          } finally {
            exports.__interactionsRef.current = prevInteractions;
            try {
              if (subscriber !== null) {
                subscriber.onWorkStopped(interactions, threadID);
              }
            } finally {
              if (interaction.__count--, subscriber !== null && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            }
          }
        }
      }
      return returnValue;
    };
    exports.unstable_unsubscribe = function(subscriber) {
      subscribers.delete(subscriber);
      subscribers.size === 0 && (exports.__subscriberRef.current = null);
    };
    exports.unstable_wrap = function(callback) {
      function wrapped() {
        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = wrappedInteractions;
        subscriber = exports.__subscriberRef.current;
        try {
          try {
            if (subscriber !== null) {
              subscriber.onWorkStarted(wrappedInteractions, threadID);
            }
          } finally {
            try {
              var returnValue = callback.apply(void 0, arguments);
            } finally {
              if (exports.__interactionsRef.current = prevInteractions, subscriber !== null) {
                subscriber.onWorkStopped(wrappedInteractions, threadID);
              }
            }
          }
          return returnValue;
        } finally {
          hasRun || (hasRun = !0, wrappedInteractions.forEach(function(interaction) {
            interaction.__count--;
            if (subscriber !== null && interaction.__count === 0) {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            }
          }));
        }
      }
      var threadID = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, wrappedInteractions = exports.__interactionsRef.current, subscriber = exports.__subscriberRef.current;
      if (subscriber !== null) {
        subscriber.onWorkScheduled(wrappedInteractions, threadID);
      }
      wrappedInteractions.forEach(function(interaction) {
        interaction.__count++;
      });
      var hasRun = !1;
      wrapped.cancel = function() {
        subscriber = exports.__subscriberRef.current;
        try {
          if (subscriber !== null) {
            subscriber.onWorkCanceled(wrappedInteractions, threadID);
          }
        } finally {
          wrappedInteractions.forEach(function(interaction) {
            interaction.__count--;
            if (subscriber && interaction.__count === 0) {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            }
          });
        }
      };
      return wrapped;
    };
  })();
};

//# sourceMappingURL=module$node_modules$scheduler$cjs$scheduler_tracing_development.js.map
